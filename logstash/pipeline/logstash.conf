input {
    tcp {
        port => 5000
        codec => multiline {
            pattern => "^%{TIMESTAMP_ISO8601} "
            negate => true
            what => previous
        }
    }
}


filter {
	if " ERROR:" in [message]{
		## Get error messages
		grok{
				match => [ "message", "%{TIMESTAMP_ISO8601}%{SPACE}%{NOTSPACE}%{SPACE}%{LOGLEVEL}%{NOTSPACE}%{SPACE}%{GREEDYDATA:error_msg}" ]
			}
		grok{
				match => [ "message", "%{DATE_EU:timestamp}" ]
			}
		date{
		    	match => [ "timestamp", "yy-MM-dd" ]
		   		target => "@timestamp"
			}
		}

	else if "Dumping Scrapy stats" in [message] {
		grok{
				match => [ "message", "'item_scraped_count': %{NUMBER:scraped:int}" ]
		}
		grok{
				match => [ "message", "'invalid_items_count': %{NUMBER:invalid:int}" ]
		}
		grok{
				match => [ "message", "'in_stock_items_count': %{NUMBER:instock:int}" ]
		}
		grok{
				match => [ "message", "'out_stock_items_count': %{NUMBER:outofstock:int}" ]
		}
		grok{
				match => [ "message", "'zero_price_items_count': %{NUMBER:zeropriced:int}" ]
		}
		grok{
				match => [ "message", "'iteration_duration': %{NUMBER:duration:float}" ]
		}
		grok{
				match => [ "message", "'item_dropped_count': %{NUMBER:dropped:int}" ]
		}
		grok{
				match => [ "message", "%{DATE_EU:timestamp}" ]
		}
		date{
		    	match => [ "timestamp", "yy-MM-dd" ]
		   		target => "@timestamp"
		}	

		}

	else{
		## Get merchant name
		grok{
				match => [ "message", "Crawled iteration for merchant %{WORD:merchant_name} started" ]
			}
		grok{
			 	match => [ "message", "%{DATE_EU:timestamp}" ]
		}
		date{
		   	 	match => [ "timestamp", "yy-MM-dd" ]
		   		target => "@timestamp"
		}	
		}
}


output {
	if "_grokparsefailure" not in [tags]{
		
		stdout {
		codec => rubydebug
		}

		elasticsearch {
			hosts => "elasticsearch:9200"
			index => "logstash-%{+YYYY.MM}"
		}
	}
}
