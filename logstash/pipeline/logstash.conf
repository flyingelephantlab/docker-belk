input {
    tcp {
        port => 5000
        codec => multiline {
            pattern => "^%{TIMESTAMP_ISO8601} "
            negate => true
            what => previous
        }
    }
}



filter {

	if "Dumping Scrapy stats" in [message] {

		## Scraped items, invalid items
		grok{
				match => [ "message", "'item_scraped_count': %{NUMBER:scraped_items:int}" ]
		}
		grok{
				match => [ "message", "'invalid_items_count': %{NUMBER:invalid_items:int}" ]
		}

		aggregate {
        	task_id => "%{type}"
        	code => "
        		map['scraped_items_agg'] = event.get('scraped_items')
        		map['invalid_items_agg'] = event.get('invalid_items')
        		"
			map_action => "update"
			end_of_task => true
       		push_previous_map_as_event => true
    	    }

	}

	else{
		grok{
				match => [ "message", "Crawled iteration for merchant %{WORD:merchant_name} started" ]
			}

		aggregate {
        	task_id => "%{type}"
        	code => "
        		map['merchant_name_agg'] = event.get('merchant_name')
        		"
			map_action => "create"
    	    }			
		}

		if "_grokparsefailure" in [tags] {            
				drop { }
			}

		grok{
			    match => [ "message", "%{DATE_EU:timestamp}" ]
		}
		date{
		   	 	match => [ "timestamp", "yy-MM-dd" ]
		   		target => "@timestamp"	
		   	}
}


output {
	if "_grokparsefailure" not in [tags]{
	
		stdout {
		codec => rubydebug
		}

		elasticsearch {
			hosts => "elasticsearch:9200"
			index => "logstash-%{+YYYY.MM}"
		}

	}
}
