input {

    file {
        path => ["/logs/logs/ariika/01012017.log"]
        codec => multiline {
            pattern => "^%{TIMESTAMP_ISO8601} "
            negate => true
            what => previous
        }
        sincedb_path => "/dev/null"
        start_position => "beginning"
    }
}



filter {
	grok {
    	match => ["path","%{GREEDYDATA}/%{GREEDYDATA:merchant_name}/%{GREEDYDATA}\.log"]
  	}
  	mutate{
			add_field => { "status" => "Running" }
	}
	grok{
	    match => [ "message", "%{DATE_EU:timestamp}" ]
	}

	date{
   	 	match => [ "timestamp", "yy-MM-dd" ]
   		target => "@timestamp"	
   	}

	## Unfinished Logs
	if "WARNING: Dropped: Item is not valid" in [message]{
		grok{
        		match => [ "message", "'url_en': '%{GREEDYDATA:unfinished_dropped_url}'" ]
    		}
		grok{
				match => [ "message", ".*status\'\:\s\'(?<unfinished_stock_status>\w*)" ]
		}
	}

	else if "DEBUG: Scraped from" in [message]{
		grok{
        		match => [ "message", "'url_en': '%{GREEDYDATA:unfinished_scraped_url}'" ]
    		}
		grok{
				match => [ "message", ".*status\'\:\s\'(?<unfinished_stock_status>\w*)" ]
		}
	}

	else if " ERROR:" in [message]{
		## Get error messages
		grok{
				match => [ "message", "%{TIMESTAMP_ISO8601}%{SPACE}%{NOTSPACE}%{SPACE}%{LOGLEVEL}%{NOTSPACE}%{SPACE}%{GREEDYDATA:error_msg}" ]
			}		
	}

	else if "Dumping Scrapy stats" in [message] {

		grok{
				match => [ "message", "'item_scraped_count': %{NUMBER:scraped:int}" ]
		}
		grok{
				match => [ "message", "'invalid_items_count': %{NUMBER:invalid:int}" ]
		}
		grok{
				match => [ "message", "'in_stock_items_count': %{NUMBER:instock:int}" ]
		}
		grok{
				match => [ "message", "'out_stock_items_count': %{NUMBER:outofstock:int}" ]
		}
		grok{
				match => [ "message", "'zero_price_items_count': %{NUMBER:zeropriced:int}" ]
		}
		grok{
				match => [ "message", "'iteration_duration': %{NUMBER:duration:float}" ]
		}
   		mutate{
   				update => { "status" => "Finished" }
		}	
	}

	else{
		grok{
				match => [ "message", "%{TIMESTAMP_ISO8601} %{NOTSPACE} WARNING: Item at url %{GREEDYDATA:unfinished_invalid_items} is not valid because it is missing" ]
		}		
	}

	
	if "_grokparsefailure" in [tags] {            
		drop { }
	}

	else{
	aggregate {
	        task_id => "%{merchant_name}"
	        code => "
	         map['merchant_name'] = event.get('merchant_name');
	         map['status'] = event.get('status');
	         map['crawl_date'] = event.get('timestamp');
	         map['scraped'] = event.get('scraped_items');
	         map['invalid'] = event.get('invalid_items');
	         map['instock'] = event.get('instock');
	         map['outofstock'] = event.get('outofstock');	
	         map['zeroprice'] = event.get('zeropriced');
	         map['duration'] = event.get('duration');
	         map['unfinished_scraped'] = event.get('unfinished_scraped_url');
	         map['unfinished_stock'] = event.get('unfinished_stock_status');
	         map['unfinished_dropped'] = event.get('unfinished_dropped_url');
	         map['unfinished_invalid'] = event.get('unfinished_invalid_items');	         
	         map['errors'] = event.get('error_msg');
	         event.cancel()        
	        "
	        push_previous_map_as_event => true
   		}
   	}

	if "_aggregatefinalflush" in [tags] { 
		date{
	   	 	match => [ "crawl_date", "yy-MM-dd" ]
	   		target => "@timestamp"	
	   	}
	}
	
}


output {
		stdout {
			codec => rubydebug
		}

		elasticsearch {
			hosts => "elasticsearch:9200"
			index => "logstash-%{merchant_name}"
		}
}