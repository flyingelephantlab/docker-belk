input {
  beats {
    port => 5044
    ssl => true
    ssl_certificate => "/etc/ssl/server/logstash.crt"
    ssl_key => "/etc/ssl/server/logstash.key"
  }
}

## Add filters / logstash plugins configuration here

filter {

	ruby {
        code => "event.set('merchant_name', event.get('source').split('/')[-2])"
    }

	date{
   	 	match => [ 'timestamp', 'yy-MM-dd' ]
   		target => '@timestamp'
   	}

   	grok{
	    match => [ 'message', '%{DATE_EU:timestamp}' ]
	}

    mutate {
        add_field => { "spider_state" => "init" }
    }

    if "INFO: Starting spider" in [message] {

        mutate { update => { "spider_state" => "running" } }

        grok {
            match => [ "message", "%{GREEDYDATA:open_msg}" ]
        }
    }

    else if "INFO: Spider closed" in [message]{

        mutate { update => { "spider_state" => "finished" } }

        grok {
            match => [ "message", "%{GREEDYDATA:finish_msg}" ]
        }
    }

    if [spider_state] == "init"{
        drop {}
    }

    if [spider_state] == "finished"{

        if "Dumping Scrapy stats" in [message] {

            grok{
                    match => [ "message", "'item_scraped_count': %{NUMBER:scraped:int}" ]
            }
            grok{
                    match => [ "message", "'invalid_items_count': %{NUMBER:invalid:int}" ]
            }
            grok{
                    match => [ "message", "'in_stock_items_count': %{NUMBER:instock:int}" ]
            }
            grok{
                    match => [ "message", "'out_stock_items_count': %{NUMBER:outofstock:int}" ]
            }
            grok{
                    match => [ "message", "'zero_price_items_count': %{NUMBER:zeropriced:int}" ]
            }
            grok{
                    match => [ "message", "'iteration_duration': %{NUMBER:duration:float}" ]
            }

        }

        else if " ERROR:" in [message]{
            grok{
                match => [ "message", "%{TIMESTAMP_ISO8601}%{SPACE}%{NOTSPACE}%{SPACE}%{LOGLEVEL}%{NOTSPACE}%{SPACE}%{GREEDYDATA:error_msg}" ]
            }
        }

        else{
            drop {}
        }
    }

	else if [spider_state] == "running"
	{

        ruby {
            code => "event.set('spider_elapsed', Time.now.to_f - event.get('@timestamp').to_f)"
        }

		if "WARNING: Dropped: Item is not valid" in [message]{
			grok{
        		match => [ "message", "'url_en': '%{GREEDYDATA:unfinished_dropped_url}'" ]
    		}
			grok{
				match => [ "message", ".*status\'\:\s\'(?<unfinished_stock_status>\w*)" ]
			}
		}

		else if "DEBUG: Scraped from" in [message]{
			grok{
        		match => [ "message", "'url_en': '%{GREEDYDATA:unfinished_scraped_url}'" ]
    		}
			grok{
				match => [ "message", ".*status\'\:\s\'(?<unfinished_stock_status>\w*)" ]
			}
		}

		else if " ERROR:" in [message]{
			grok{
				match => [ "message", "%{TIMESTAMP_ISO8601}%{SPACE}%{NOTSPACE}%{SPACE}%{LOGLEVEL}%{NOTSPACE}%{SPACE}%{GREEDYDATA:error_msg}" ]
			}
		}

		else if "WARNING: Item at url" in [message]{
			grok{
				match => [ "message", "%{TIMESTAMP_ISO8601} %{NOTSPACE} WARNING: Item at url %{GREEDYDATA:unfinished_invalid_items} is not valid because it is missing" ]
			}
		}

		else{
			drop {}
		}
	}

}

output {
    if "_grokparsefailure" not in [tags]{
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "logstash-%{merchant_name}"
        }
        stdout { codec => rubydebug }
	}
}
